\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage{color}
\usepackage{float}
\usepackage{fancyvrb}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{comment}

\usepackage{graphicx}
\DeclareGraphicsExtensions{.png}

\definecolor{dkgreen}{rgb}{0,0.45,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.30,0,0.30}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\footnotesize,
  keywordstyle=\color{dkgreen}\bfseries,
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=false
  tabsize=1
}
\begin{comment}
\begin{lstlisting}
	Copy this and input code here
\end{lstlisting}
\end{comment}

\title{Programming Languages \\Project 1 \\\rule{10cm}{0.5mm}}
\author{Troels Blicher Petersen\\trpet15
\\ DM552\\\rule{5.5cm}{0.5mm}\\}
\date{15/11-2016}

\begin{document}

\maketitle

\vfill

\newpage
\tableofcontents

\newpage
\section{Task 1}
\subsection{The Logic}
Since this is a project based around propositional logic, there is a need to define a set of logical operators for use later on. \\
At the very fist, negation is defined. Negation is very simple, since it is always the opposite of the negated value. In Prolog negation is defined as \textbackslash +. In this project, negation is being defined with the predicate \textsf{neg/1}.\\
The predicate \textsf{and/2} is also defined using Prologs built in mechanics. \textsf{and/2} returns true when both X and Y are true.\\
Now with negation and "and" in place, it is possible to create every other operator using only these two.\\
Therefore \textsf{or/2}, \textsf{impl/2}, \textsf{xor/2} and \textsf{equiv/2} are all defined by nested and's and negations.
\subsection{wff/1}
A \textit{well-formed formula} is a formula where there is no ambiguity in the relation between variables and logic operators. And example of an ambiguous formula could be $A \land B \lor C$, whereas a well-formed formula of the same would look like $(A \land (B \lor C))$.\\
To check for wff is therefore quite simple, since every operator is surrounded by and X and a Y. X and Y can be either a value or another formula of the same form. This means that \textsf{wff/1} needs to be defined for all the possible occuring cases. One example could be \textsf{wff(and(X, Y))}. Here \textsf{wff/1} branches to a wff with the input X and a wff with the input Y. This is the same for every case of \textsf{wff/1}. When \textsf{wff/1} reaches a leaf node in the recursion tree, it needs to return the value true, since that must mean that the current branch of the formula is well-formed. To do this, \textsf{wff(X)} is checking whether X is the same as X. This will be true everytime, and makes \textsf{wff/1} it indifferent to the variables of the formula. This means that \textsf{wff/1} does not care whether the variables of the formula makes the formula true or false, but instead only checks whether the formula itself is well-formed.
\subsection{satisfies/2}
\textsf{satisfies/2} is where one can check whether the input values makes the formula true or false. In this project, the variables of the formula are defined as \textsf{p(X)}. They are regared as true if X exists in the valuation list V; if not, then \textsf{p(X)} is false in the formula.\\
Checking whether the formula F is true with the valuation V, is very similar to \textsf{wff/1}. There is a case for all the inputs of that F can have, and then it branches the recursion tree based on that. This time when the leaf node is reached, the value of \textsf{p(X)} is searched for in the valuation list V. If X exists in the list V, it returns true. If not, it returns false. However, just because it returns false, it does not mean the formula should return false. All the logic behind this is being done in all the parent nodes of the leafs. These parent nodes' truth value are determined on the basis of the child nodes. When all has been recursed and backtracked, the satisfiability is determined by whether the last state was false or true.\\\\
However, \textsf{satisfies/2} is not the only predicate used in to determine the satisfiability of a formula. To check whether X exists in V the predicate \textsf{list\_contains/2} is needed. \textsf{list\_contains/2} starts out by checking whether X is the first element of the list. This is done with \textsf{list\_contains([X|\_], X).} If X is not the first item, it checks the next element of the list. By setting the second element of the list to the first element of a new list, it is possible to recursively check whether X is in the valuation list. Again, if X is in the list, \textsf{list\_contains/2} returns true and otherwise false.
\subsection{find\_val\_tt/2}
\textsf{find\_val\_tt/2} resuses a lot of the work done by \textsf{satisfies/2}, since  \textsf{satisfies/2} checks whether a valuation, V, for the formula, F, is true or false. What makes \textsf{find\_val\_tt/2} different, is that it needs to find all the values of the formula and then put these in a list. This list and all of its permutations are used to in \textsf{satisfies/2}. Since V in \textsf{find\_val\_tt/2} has not been defined at execution, it will return a list in all the cases where \textsf{find\_val\_tt/2} is true.\\
The predicate \textsf{find\_val\_tt/2} works by calling a sort of derived predicate called \textsf{find\_val/2}. \textsf{find\_val/2} is in many regards very similar to \textsf{satisfies/2}. The only difference is the base case and when backtracking. The base case takes the value of \textsf{p(X)} and adds it to a list using one of Prolog's built in functions \textsf{append/3}. When it starts backtracking, it adds all the base cases to a list. This list is then returned from \textsf{find\_val/2}. However, the returned list is made up of nested lists with nested lists and so on. This means that it isn't possible right away to use the list in \textsf{satisfies/2}. To circumvent this problem, Prolog has a built in predicate \textsf{flatten/2}, which flattens the list. However, there is still a minor problem. The now flattened list may contain duplicates. Duplicates in itself is not a problem, however, they might slow down the program significantly - more about that later. It turns out that Prolog's built-in sort predicate \textsf{sort/2} not only sorts the input list, it also removes any duplicates. Therefore \textsf{sort/2} is used.\\
Now to find all the valuations that makes the formula true, it is required to test all permutations of the now sorted list. It is important that it is permutations of the list and not just sublists of the list. The difference lies in the fact that [1,3] is not a sublist of [1,2,3], however, [1,3] is a permutation of [1,2,3]. To make such a permutation a new predicate \textsf{permutations/2} is required. First of all \textsf{permutations/2} has a base case \textsf{permutations([],[]).} This base case states that the permuted list of an empty list, is only the empty list. The next two clauses of \textsf{permutations/2} controls what to do with a non-empty list. In the first clause it is stated that if the first element of the first list is the same as the first element of the output list, then the output list must be a subset of the input list. However, this is only the case if we have the second clause. Otherwise it would only be a way to tell whether two lists are the same. The second clause deals with the permuted subsets of the input list. It states that the output list is a subset of the tail of the input list. When executing \textsf{permutations/2} it will therefore output all the permuted lists of the input list - this includes the empty list. It is important to note that \textsf{permutations/2} is not dependent on sorted lists. If the input list is unsorted, it will simply return all the permuted lists in a different order.\\
Now back to the duplicates. When finding all permutations of a lists that holds duplicates, the amount of work is greatly increased. For an example the list [1,2,2] would output [1,2] two times, since the "2"'s are not regarded as the same when find permutations of a list. For the sake of removing unnessesary overhead, duplicates therefore has to be removed.\\
Another thing to note in \textsf{find\_val\_tt/2} is the lack of any cuts. The reason for this is that the user can then get all the lists where the formula is satisfied.
\subsection{taut\_tt/1, sat\_tt/1 \& unsat\_tt/1}

\end{document}
