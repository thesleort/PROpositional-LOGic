/* a symbol p(N) is a propositional symbol if N is a positive integer, thus between 1 and positive infinity. */
/* something is a propositional formula iff it contains propositional symbols and legal connectives upon these. */

wff(p(N)) :- N>0.
wff(equiv(N,M)) :- wff(N),wff(M).
wff(neg(N)) :- wff(N).
wff(impl(N,M)) :- wff(N),wff(M).
wff(and(N,M)) :- wff(N),wff(M).
wff(or(N,M)) :- wff(N),wff(M).
wff(xor(N,M)) :- wff(N),wff(M).



/* a valuation satisfies a propositional formula if in every connective the elements have truth values such the overall formula holds*/
/* we want to use satisfies in find_val_tt in such a way that it should not backtrack when it finds a correct answer. */
/* we can not issue a cut before we have a correct answer, thus we use sat/2 to do the actual evaluation. */

satisfies(List, N) :- sat(List, N),!.
sat(List,p(N)):- contains(List,N).
sat(List,neg(N)) :- not(sat(List, N)).
sat(List,and(N,M)):- sat(List,N),sat(List,M).
sat(List,impl(_N,M)):- sat(List,M).
sat(List,impl(N,_M)) :- sat(List, neg(N)).
sat(List,or(_N,M)) :- sat(List,M).
sat(List,or(N,_M)) :- sat(List,N).
sat(List,equiv(N,M)) :- sat(List,N),sat(List,M).
sat(List,equiv(N,M)) :- not(sat(List,N)),not(sat(List,M)).
sat(List,xor(N,M)) :- sat(List,N),not(sat(List,M)).
sat(List,xor(N,M)) :- sat(List,M),not(sat(List,N)).


/* a list contains an element N if the head of the list is equal to N or N is in the tail*/
contains([H|_T],H).
contains([_H|T],N) :- contains(T,N),!.


/* a relevant valuation is interpreted as either A. the empty list or B. a list containing only integers of propositional symbols from the propositional formula */
/* all relevant evaluations are equal to the power set of a list List_of_symbols containing all propositional symbols of the formula F and thus can be generated from List_of_symbols. */
/* when all relevant symbols have been found, we do not wish to backtrack. we therefore issue a cut*/
/* each valuation must be checked with satisfies/2. if a valuation holds for a formula F, we do not need to go on and so we issue a cut.*/

find_val_tt(F, V) :- find_all_symbols(F, List_of_symbols),!, find_valuations(List_of_symbols, V),satisfies(V, F),!.


/* extracts all relevant symbols from a given formula. a propositional symbol is relevant if it can be found in a propositional formula F */
/* we must check every symbol as we do not know if N is from the set {1,2,3,...} or {1,3,5,...} etc. */
/* the propositional symbols of a connective must be equal to the unified set of its elements. thus, when we unify two lists we need to make sure that these lists contain unique elements*/
find_all_symbols(p(N), [N]).
find_all_symbols(neg(N), Set_of_symbols) :- find_all_symbols(N, Set_of_symbols).
find_all_symbols(equiv(N,M), Set_of_symbols) :- find_all_symbols(N, X),find_all_symbols(M, Y),zip_sets(X, Y, Set_of_symbols). 
find_all_symbols(impl(N,M), Set_of_symbols) :- find_all_symbols(N, X),find_all_symbols(M, Y),zip_sets(X, Y, Set_of_symbols). 
find_all_symbols(and(N,M), Set_of_symbols) :- find_all_symbols(N, X),find_all_symbols(M, Y),zip_sets(X, Y, Set_of_symbols). 
find_all_symbols(or(N,M), Set_of_symbols) :- find_all_symbols(N, X),find_all_symbols(M, Y),zip_sets(X, Y, Set_of_symbols). 
find_all_symbols(xor(N,M), Set_of_symbols) :- find_all_symbols(N, X),find_all_symbols(M, Y),zip_sets(X, Y, Set_of_symbols). 


/* zips two sets together. the head H of a list A should be added to a list B if and only if H is not in B. */
zip_sets([], N, N).
zip_sets([H|T], N, L) :- not(contains(N,H)), zip_sets(T, [H|N], L).
zip_sets([_H|T], N, L) :- zip_sets(T, N, L).

/* finds all subsets of a list L one at a time, a subset being a valuation. an element of the list is either in a valuation or not. */
/*if L contains n elements then for an element at index i, 2*2^(n-i) different valuations are generated. the multiplier of 2 is because the element at index i is also either part of valuations or not */ 
find_valuations([],[]).
find_valuations([H|T], [H|Comb]) :- find_valuations(T, Comb).
find_valuations([_H|T], Comb) :- find_valuations(T, Comb).

/* a formula is satisfiable if we can find a valuation that makes it true. we cut because we do not need to look for more valuations if we find one*/
sat_tt(F) :- find_val_tt(F,_),!.

/* a formula is unsatisfiable if we can not find a valuation that makes it true */
unsat_tt(F) :- not(find_val_tt(F,_)).

/* a formula F is a tautology if neg(F) is unsatisfiable */
taut_tt(F) :- unsat_tt(neg(F)).


/* the leaves of a tableau are generated by using the given rules for connectives. */
/* if a connective requires for both its elements to have certain truth values then a leaf would contain the required truth values of both these elements*/
/* in other words, such a leaf would be a union (zipped) of the required truth value lists of the elements. */
tableau(p(N),[p(N)]).
tableau(neg(p(N)),[neg(p(N))]).

tableau(neg(neg(N)),V) :- tableau(N,V).


tableau(and(N,M),V) :- tableau(N,V1),tableau(M,V2),zip(V1,V2,V).

tableau(neg(and(N,_M)),V) :- tableau(neg(N),V).
tableau(neg(and(_N,M)),V) :- tableau(neg(M),V).

tableau(impl(N,_M),V) :- tableau(neg(N),V).
tableau(impl(_N,M),V) :- tableau(M,V).

tableau(neg(impl(N,M)),V) :- tableau(N,V1),tableau(neg(M),V2),zip(V1,V2,V).

tableau(or(N,_M),V) :- tableau(N,V).
tableau(or(_N,M),V) :- tableau(M,V).

tableau(neg(or(N,M)),V) :- tableau(neg(N),V1),tableau(neg(M),V2),zip(V1,V2,V).

tableau(equiv(N,M),V) :- tableau(N,V1),tableau(M,V2),zip(V1,V2,V).
tableau(equiv(N,M),V) :- tableau(neg(N),V1),tableau(neg(M),V2),zip(V1,V2,V).

tableau(neg(equiv(N,M)),V) :- tableau(neg(N),V1),tableau(M,V2),zip(V1,V2,V).
tableau(neg(equiv(N,M)),V) :- tableau(N,V1),tableau(neg(M),V2),zip(V1,V2,V).

tableau(xor(N,M),V) :- tableau(N,V1),tableau(neg(M),V2),zip(V1,V2,V).
tableau(xor(N,M),V) :- tableau(neg(N),V1),tableau(M,V2),zip(V1,V2,V).

tableau(neg(xor(N,M)),V) :- tableau(N,V1),tableau(M,V2),zip(V1,V2,V).
tableau(neg(xor(N,M)),V) :- tableau(neg(N),V1),tableau(neg(M),V2),zip(V1,V2,V).

/* ZIPS TWO LISTS TOGETHER */
zip([],N,N).
zip([H|T],N,L) :- zip(T,[H|N],L).


/* satisfies/2 takes a different representation of valuations than the ones tableau/2 generates. */
/* whenever we reach a leaf of the tableaux we must generate it to a valuation that satisfies/2 understand. when we have found a valuation, we do not need to look further and thus issue a cut */
find_val_tab(F,V) :- tableau(F,V1),convert(V1,V),satisfies(V,F),!.



/*transforms a leaf of tableau/2 in a valuation that satisfies/2 understands. a list [p(N),neg(p(M)),p(Z)] created by tableau/2 is 
equivalent to the list [N,Z] which satisfies/2 understands*/
/*therefore, for every p(N), N needs to be in the valuation, and for every neg(p(M)), M should not be in the valuation */
/*we need to make cuts so we don't risk printing sublists when backtracking. this is because we use an anonymous variable to save space in the third horn clause. */
/*if unification succeeds with the head of the second clause we can make a cut whereever in the body and it will be a green cut*/
/*this is because we could have unified with the clause in one way and one way only. */
convert([], []).
convert([p(N)|V],[N|New_V]) :- convert(V,New_V),!.
convert([_|V],New_V) :- convert(V,New_V).		/* we can only have encountered a neg(p(N)) now, thus we should not add it to the resulting list */

/* check the comments of sat_tt/2, unsat_tt/2 and taut_tt/2 for an explanation*/
sat_tab(L) :- find_val_tab(L,_).

unsat_tab(L) :- not(find_val_tab(L,_)).

taut_tab(L) :- unsat_tab(neg(L)).
